#include <algorithm>

class Solution
{
public:
    // Функция, которая вычисляет, сколько единиц воды может быть поймано после дождя.
    // Параметр height — вектор, представляющий высоты столбцов (elevation map).
    int trap(const std::vector<int>& height) {
        // Если вектор пустой, никакая вода не может быть поймана.
        if (height.empty()) {
            return 0;
        }

        int n = height.size();  // Общее количество столбцов

        // Создаем два вектора для хранения максимальной высоты слева и справа для каждой позиции.
        std::vector<int> left_max(n, 0);   // left_max[i] будет содержать максимальную высоту от 0 до i
        std::vector<int> right_max(n, 0);  // right_max[i] будет содержать максимальную высоту от i до n-1

        // Для первого столбца максимальная высота слева равна самой высоте столбца.
        left_max[0] = height[0];

        // Заполняем массив left_max.
        // Для каждого столбца от 1 до n-1 находим максимум между left_max[i-1] и высотой текущего столбца.
        for (size_t i = 1; i < n; ++i) {
            left_max[i] = std::max(left_max[i - 1], height[i]);
        }

        // Для последнего столбца максимальная высота справа равна самой высоте столбца.
        right_max[n - 1] = height[n - 1];

        // Заполняем массив right_max.
        // Для каждого столбца от n-2 до 0 находим максимум между right_max[i+1] и высотой текущего столбца.
        for (int i = n - 2; i >= 0; --i) {
            right_max[i] = std::max(right_max[i + 1], height[i]);
        }

        int trapped_water = 0;  // Переменная для накопления общего объема пойманной воды.

        // Проходим по каждому столбцу и рассчитываем, сколько воды может быть собрано над ним.
        // Количество воды над столбцом определяется как разница между минимумом из left_max и right_max
        // и самой высотой столбца. Если разница отрицательная, то добавляем 0, так как вода не скапливается.
        for (size_t i = 0; i < n; ++i) {
            trapped_water += std::min(left_max[i], right_max[i]) - height[i];
        }

        // Возвращаем общий объем собранной воды.
        return trapped_water;
    }
};
