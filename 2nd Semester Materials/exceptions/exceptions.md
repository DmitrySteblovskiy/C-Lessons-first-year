# Исключения в C++

Исключения в C++ позволяют обрабатывать ошибки, возникающие во время выполнения программы, отделяя код обработки ошибок от основного логического потока (на паре вспоминали и про отдельный поток вывода ошибок cerr). В стандартной библиотеке C++ все исключения наследуются от базового класса `std::exception`.

------------------------------------------------------------
## Иерархия исключений в STL

- **std::exception**  
  Базовый класс для всех стандартных исключений.

- **std::logic_error**  
  Представляет ошибки, связанные с нарушением логики работы программы (например, передача неверных аргументов). Примеры:  
  • `std::invalid_argument`  
  • `std::domain_error`  
  • `std::length_error`

- **std::runtime_error**  
  Относится к ошибкам, обнаруживаемым только во время выполнения. Ситуациями для использования являются:
  - Попытка открыть несуществующий файл.
  - Ошибки, связанные с выделением памяти или неверным состоянием ввода/вывода.
  
  Пример использования `std::runtime_error`:
  
```cpp
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <string>

void readFile(const std::string &filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("Не удалось открыть файл: " + filename);
    }
    // Обработка файла...
}

int main() {
    try {
        readFile("data.txt");
    } catch (const std::exception &e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
    return 0;
}
```

- **Compile Time Errors**  
 В C++ нет специального класса исключения для вывода таких ошибок, так как они не выбрасываются в рантайме. Вместо этого юзаем `static_assert`, о которых мы уже говорили ранее

## Спецификатор и оператор noexcept

Спецификатор `noexcept` позволяет заявить, что функция гарантированно не выбрасывает исключений. Это может помочь компилятору в оптимизациях и улучшить безопасность кода. При нарушении контракта (функция, объявленная как `noexcept`, тем не менее выбрасывает исключение) вызывается `std::terminate`.

Также существует оператор `noexcept`, который позволяет в выражениях узнать, гарантирует ли вызов функции отсутствие выброса исключения (возвращает `true` или `false`).

```cpp
#include <iostream>
#include <stdexcept>

void safeFunction() noexcept {
    std::cout << "Функция safeFunction не выбрасывает исключений." << std::endl;
}
```

### Примеры noexcept в STL

Многие стандартные контейнеры и функции оптимизированы с использованием `noexcept`. Например:
- Деструкторы и перемещающие конструкторы некоторых контейнеров (например, `std::vector`, `std::unique_ptr`) часто объявлены как `noexcept` для эффективности
- Методы по типу `pop_back()` у `std::vector` обычно `noexcept`, так как он не выделяет память и не может выбросить исключение.
- В то же время, методы, которые могут потребовать выделения памяти (например, `push_back()`) не гарантированы как `noexcept`.

Проверка на уровне выражений с использованием оператора `noexcept`:

```cpp
#include <iostream>
#include <vector>
#include <utility> // для std::declval

int main() {
    std::vector<int> vec;
    std::cout << std::boolalpha;
    std::cout << "std::vector<int>::pop_back() noexcept? " 
              << noexcept(vec.pop_back()) << std::endl;
    
    // Для push_back в данном случае результат может зависеть от реализации,
    // так как возможна аллокация памяти.
    std::cout << "std::vector<int>::push_back() noexcept? " 
              << noexcept(vec.push_back(42)) << std::endl;
    return 0;
}
```

