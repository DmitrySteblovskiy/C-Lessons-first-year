
# Перегрузка функций и шаблоны в C++

## 1. Перегрузка функций

Перегрузка функций — это возможность в C++ создавать несколько функций с одним и тем же именем, но с разными параметрами. Это позволяет вызывать нужную функцию в зависимости от переданных аргументов.

### Пример

```
// Функция для сложения двух целых чисел
int add(int a, int b) {
    return a + b;
}

// Перегруженная функция для сложения двух чисел с плавающей точкой
double add(double a, double b) {
    return a + b;
}

int main() {
    int intResult = add(5, 3);       // Вызовет int add(int, int)
    double doubleResult = add(5.5, 3.3); // Вызовет double add(double, double)
}
```

В этом примере одна функция `add` принимает и возвращает `int`, а другая принимает и возвращает `double`. В зависимости от переданных аргументов вызывается необходимая функция.

## 2. Шаблоны (Templates)

Шаблоны позволяют писать универсальный код, который может работать с различными типами данных. Это значит, что можно определить функцию или класс, которая будет работать с любым типом, указанным при создании экземпляра шаблона.

### Примеры использования шаблонов для перегрузки функций

Шаблоны можно использовать для создания обобщенной версии функции, которая будет работать с разными типами данных.

```
// Шаблонная функция для сложения двух значений
template <typename T>
T add(T a, T b) {
    return a + b;
}

// Можно также иметь перегруженные версии шаблонных функций для специальной логики
template <>
std::string add<std::string>(std::string a, std::string b) {
    return a + " " + b;
}

int main() {
    int intResult = add(5, 3);
    double doubleResult = add(5.5, 3.3);
}
```

В этом примере шаблонная функция `add` может принимать два значения любого типа и возвращать их сумму. Мы также продемонстрировали специализацию шаблонной функции для `std::string`, чтобы она добавляла пробел между словами.


```markdown
# Различия в файлах .h, .hpp, .cc, .cpp, .c и их назначение

## 1. Типы файлов и их назначение

### a) Заголовочные файлы (.h, .hpp)
- **.h**: Стандартное расширение для заголовочных файлов C/C++. Они содержат объявления функций, классов, структур и макросов. Обычно используются для разделения интерфейса и реализации.
- **.hpp**: Также используется для заголовочных файлов, часто в C++. Обычно применяются для заголовков, которые содержат шаблонные классы и функции, но это не строгая практика.

### b) Исходные файлы (.c, .cpp, .cc)
- **.c**: Расширение для исходных файлов на языке C. Они содержат определения функций и являются основной частью кода программ на C.
- **.cpp**: Служит для исходных файлов C++. Эти файлы содержат определения классов и методов для C++ программ.
- **.cc**: Тоже расширение для исходных файлов C++. Менее распространено, но многие разработчики предпочитают его в зависимости от личных или корпоративных предпочтений.

## 2. Компиляция
- Заголовочные файлы (`.h`, `.hpp`) сами по себе не компилируются. Они включаются в исходные файлы при помощи директивы `#include`.
- Исходные файлы (`.c`, `.cpp`, `.cc`) компилируются в объектные файлы с помощью компилятора (`gcc` для C и `g++` для C++). Затем эти объектные файлы связываются вместе для создания исполняемого файла.

## 3. Пример базового класса калькулятора

### Класс `Calculator` в файле заголовка (`Calculator.h`)

```cpp
// Calculator.h
#ifndef CALCULATOR_H
#define CALCULATOR_H

class Calculator {
public:
    // Конструктор
    Calculator();

    // Деструктор
    ~Calculator();

    // Метод суммы
    int add(int a, int b);

    // Метод умножения
    int multiply(int a, int b);
};

#endif // CALCULATOR_H
```

### Реализация класса `Calculator` в файле исходного кода (`Calculator.cc`)

```cpp
// Calculator.cc
#include "Calculator.h"
#include <iostream>

// Реализация конструктора
Calculator::Calculator() {
    std::cout << "Калькулятор создан." << std::endl;
}

// Реализация деструктора
Calculator::~Calculator() {
    std::cout << "Калькулятор уничтожен." << std::endl;
}

// Реализация метода суммы
int Calculator::add(int a, int b) {
    return a + b;
}

// Реализация метода умножения
int Calculator::multiply(int a, int b) {
    return a * b;
}
```
