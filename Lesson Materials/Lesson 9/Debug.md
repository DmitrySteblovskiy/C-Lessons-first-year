
# Отладка (дебаг)


## 1. Что такое дебаг?

**Дебаг** — это процесс обнаружения, анализа и устранения ошибок или багов в вашем коде, чтобы убедиться, что ваша программа работает должным образом. Один из простейших методов отладки — вставка операторов вывода (print) в код для мониторинга хода выполнения и состояния переменных.

### Простая отладка с помощью принтов в C++

Использование `std::cout` для отладки позволяет выводить значения переменных на разных этапах выполнения программы. Очевидно, это самый простой способ отладки

```cpp
int main() {
    int a = 5;
    int b = 10;
    if (a + b < 16) {
        std::cout << "Иф сработал" << '\n';
    }
    int sum = a + b;
    std::cout << "После сложения: сумма = " << sum << std::endl;

    // Введение ошибки: неправильное умножение
    int product = a * b;
    std::cout << "После умножения: произведение = " << product << '\n';
}
```

**Вывод:**
```
Начальные значения: a = 5, b = 10
После сложения: сумма = 15
После умножения: произведение = 50
```

**Советы по использованию:**
- Вставляйте операторы `std::cout` перед и после критических операций, чтобы отслеживать состояние переменных.
- Четко маркируйте ваши выводы для отладки, чтобы сделать вывод понятным.
- Удаляйте или комментируйте операторы вывода после устранения проблемы для очистки кода.

## 2. Что такое GDB и его основные команды

**GDB (GNU Debugger)** — инструмент для отладки приложений, написанных на C, C++ и других языках. Он позволяет инспектировать состояние программы во время её выполнения или после сбоя, что облегчает обнаружение и исправление ошибок.
Как я и говорил на паре, имхо, пользоваться интерфейсом CLion гораздо удобнее, но знать про GDB тоже полезно.

### Основные команды GDB

Вот некоторые из основных команд GDB, которые помогут начать работу:

- **Запуск GDB:**
  ```bash
  gdb ./ваша_программа
  ```
  
- **Запуск программы:**
  ```gdb
  run
  ```
  
- **Установка брейкпоинтов:**
  - По имени функции:
    ```gdb
    break main
    ```
  - По номеру строки:
    ```gdb
    break main.cpp:10
    ```

- **Просмотр брейкпоинтов:**
  ```gdb
  info breakpoints
  ```
  
- **Удаление брейкпоинтов:**
  ```gdb
  delete <номер_брейкпоинта>
  ```
  
- **Пошаговое выполнение кода:**
  - Вход внутрь функций:
    ```gdb
    step
    ```
  - Выполнение функции без входа внутрь:
    ```gdb
    next
    ```
  
- **Продолжение выполнения:**
  ```gdb
  continue
  ```
  
- **Проверка значений переменных:**
  ```gdb
  print имя_переменной
  ```
  Или для объектов C++:
  ```gdb
  print object.method()
  ```
  
- **Просмотр стека вызовов:**
  ```gdb
  backtrace
  ```
  
- **Выход из GDB:**
  ```gdb
  quit
  ```

### Пример сеанса GDB

```bash
gdb ./my_program
(gdb) break main
(gdb) run
(gdb) print a
(gdb) next
(gdb) continue
(gdb) quit
```

## 3. Установка брейкпоинтов и мониторинг в CLion

**CLion** - лучшая IDE для отладки, поскольку инструменты для дебага интегрированы непосредственно в её интерфейс.

### Установка брейкпоинтов

1. **Откройте проект в CLion:**
   Откройте C++ проект, который вы хотите отлаживать.

2. **Найдите строку кода:**
   Перейдите к строке кода, на которой вы хотите установить брейкпоинт.

3. **Установите брейкпоинт:**
   - Кликните в левом поле рядом с номером строки.
   - Появится красная точка, указывающая на установку брейкпоинта.
   
   ![Установка брейкпоинта](https://resources.jetbrains.com/help/img/idea/2021.1/debug_breakpoints.png)

4. **Условные брейкпоинты (опционально):**
   - Кликните правой кнопкой мыши по брейкпоинту.
   - Выберите "More" или "Edit Breakpoint".
   - Добавьте условие, при котором брейкпоинт будет срабатывать.

### Запуск отладчика

1. **Запустите отладку:**
   - Нажмите кнопку **Debug** на панели инструментов.
   - Либо кликните правой кнопкой мыши по функции `main` и выберите **Debug**.

2. **Программа приостанавливается на брейкпоинтах:**
   Когда программа достигнет брейкпоинта, она приостановится, позволяя вам проверить состояние.

### Мониторинг переменных

1. **Окно переменных:**
   - В окне **Debug** вы увидите панель **Variables**, которая содержит все текущие переменные и их значения.
   
   ![Панель переменных](https://resources.jetbrains.com/help/img/idea/2021.1/debug_variables.png)

2. **Наблюдения (Watches):**
   - Чтобы отслеживать конкретные переменные или выражения, добавьте их в панель **Watches**.
   - Нажмите на значок `+` в панели **Watches** и введите имя переменной или выражения.
   
   ![Панель наблюдений](https://resources.jetbrains.com/help/img/idea/2021.1/debug_watches.png)

### Вычисление выражений

1. **Вычислить выражение:**
   - Нажмите кнопку **Evaluate Expression** (значок калькулятора) в окне **Debug**.
   
2. **Введите выражение:**
   - Введите выражение, которое хотите вычислить (например, `a + b`).
   - Нажмите **Evaluate** для просмотра результата.
   
   ![Вычисление выражения](https://resources.jetbrains.com/help/img/idea/2021.1/evaluate_expression.png)

3. **Использование в наблюдениях:**
   - Вы также можете добавлять сложные выражения в панель **Watches** для постоянного мониторинга.

### Пошаговое выполнение кода

- **Step Over (F8):** Выполнить следующую строку кода без входа внутрь функций.
- **Step Into (F7):** Войти внутрь функций для пошаговой отладки.
- **Step Out (Shift+F8):** Выйти из текущей функции.
- **Resume Program (F9):** Продолжить выполнение до следующего брейкпоинта.

### Дополнительные советы

- **Просмотр стека вызовов:**
  - Панель **Call Stack** показывает последовательность вызовов функций, ведущих к текущей точке выполнения.
  
- **Изменение значений переменных при выполнении:**
  - Вы можете изменять значения переменных во время отладки, кликнув правой кнопкой мыши по ним в панели **Variables** и выбрав **Set Value**.
  
- **Использование logpoints:**
  - Вместо остановки выполнения, логпойнты позволяют выводить сообщения в консоль без изменения кода.
---

# Санитайзеры в C++

## 1. Что такое санитайзеры, их виды: TSAN, ASAN, LSAN

*Санитайзеры* (англ. *sanitizers*) — это инструменты, встроенные в компиляторы (например, GCC и Clang), предназначенные для обнаружения различных типов ошибок в коде во время выполнения программы. Они помогают разработчикам находить и исправлять такие проблемы, как утечки памяти, гонки данных и другие ошибки, которые могут быть трудны для обнаружения при обычном тестировании.

### Виды санитайзеров

1. *ASAN (Address Sanitizer)*

   - *Назначение:* Обнаружение ошибок работы с памятью, таких как выход за границы буфера, использование памяти после освобождения (use-after-free), двойное освобождение (double free) и другие.
   - *Применение:* Особенно полезен для обнаружения ошибок доступа к памяти в C и C++ приложениях.

2. *TSAN (Thread Sanitizer)*

   - *Назначение:* Обнаружение гонок данных (data races) в многопоточных приложениях.
   - *Применение:* Используется для анализа многопоточных программ, выявляя состояния, при которых несколько потоков одновременно обращаются к одной и той же памяти без надлежащей синхронизации.

3. *LSAN (Leak Sanitizer)*

   - *Назначение:* Обнаружение утечек памяти, то есть случаев, когда память выделяется, но никогда не освобождается.
   - *Применение:* Полезен для поиска и устранения утечек памяти, что важно для долгоживущих и ресурсоёмких приложений.

### Преимущества использования санитайзеров

- *Ранняя диагностика:* Помогают обнаруживать ошибки на этапе разработки, до выпуска продукта.
- *Улучшение качества кода:* Снижают количество потенциальных ошибок, повышая надежность и стабильность приложения.
- *Интеграция с инструментами разработки:* Легко интегрируются с современными IDE и системами сборки, такими как CLion и CMake.

## 2. Как явно включить санитайзеры в CLion в `CMakeLists.txt` с примером кода

Для использования санитайзеров в проекте на C++ с использованием CLion и CMake необходимо настроить соответствующие флаги компиляции и линковки. Ниже представлен пример настройки `CMakeLists.txt` для включения Address Sanitizer (ASAN), Thread Sanitizer (TSAN) и Leak Sanitizer (LSAN).

### Пример `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.28)
project(SanitizerExample)

set(CMAKE_CXX_STANDARD 23)

# Определяем опции для включения санитайзеров
option(USE_ASAN "Enable Address Sanitizer" OFF)
option(USE_TSAN "Enable Thread Sanitizer" OFF)
option(USE_LSAN "Enable Leak Sanitizer" OFF)

# Функция для добавления флагов санитайзеров
function(add_sanitizer TARGET)
    if(USE_ASAN)
        target_compile_options(${TARGET} PRIVATE -fsanitize=address -fno-omit-frame-pointer)
        target_link_options(${TARGET} PRIVATE -fsanitize=address)
    endif()
    if(USE_TSAN)
        target_compile_options(${TARGET} PRIVATE -fsanitize=thread)
        target_link_options(${TARGET} PRIVATE -fsanitize=thread)
    endif()
    if(USE_LSAN)
        target_compile_options(${TARGET} PRIVATE -fsanitize=leak)
        target_link_options(${TARGET} PRIVATE -fsanitize=leak)
    endif()
endfunction()

add_executable(SanitizerExample main.cpp)
add_sanitizer(SanitizerExample)

# if required, u could set debug mode right here:
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
endif()
```

### Инструкции по настройке в CLion

1. *Отредачьте `CMakeLists.txt`:*
   - Можно взять пример от жпт сверху.

2. *Включение санитайзеров:*
   - Перейдите в настройки CMake: *File* > *Settings* > *Build, Execution, Deployment* > *CMake*.
   - В поле *CMake options* добавьте соответствующие флаги для включения нужных санитайзеров. Например:
     - Для включения Address Sanitizer:
       
       -DUSE_ASAN=ON
```
- Для включения Thread Sanitizer:

-DUSE_TSAN=ON
       ```
     - Для включения Leak Sanitizer:
       ```
       -DUSE_LSAN=ON
       ```

4. **Пересборка проекта:**
   - После внесения изменений перестройте проект, чтобы применить новые настройки компиляции.

## 3. Пример кода с ошибками очищения памяти и использования санитайзера для поиска причины ошибки

Рассмотрим пример программы на C++, которая содержит ошибки управления памятью, такие как утечка памяти и использование уже освобождённой памяти. Использование Address Sanitizer поможет обнаружить эти ошибки.

### Пример `main.cpp`

```cpp
class String {
public:
    String(const char* str) {
        if (str) {
            size = std::strlen(str);
            data = new char[size + 1];
            std::strcpy(data, str);
        } else {
            size = 0;
            data = nullptr;
        }
    }

    ~String() {
        delete[] data;
    }

    void setString(const char* str) {
        delete[] data; // Ошибка: повторное удаление, если вызвать дважды
        size = std::strlen(str);
        data = new char[size + 1];
        std::strcpy(data, str);
    }

    void print() const {
        if (data) {
            std::cout << data << std::endl;
        }
    }

private:
    char* data;
    size_t size;
};

int main() {
    String* s = new String("Hello, World!");
    s->print();

    s->setString("Goodbye!");
    s->print();

    delete s;
    delete s; // Ошибка: двойное удаление

    return 0;
}
```

### Описание ошибок

1. **Двойное удаление памяти:**
   - В функции `main` объект `s` удаляется дважды с помощью `delete s;`, что приводит к ошибке `double free`.

2. **Утечка памяти:**
   - Если в функции `setString` вызвать `delete[] data;` несколько раз без правильной проверки, это может привести к утечке памяти или другим ошибкам.

### Запуск с использованием Address Sanitizer

1. **Сборка с ASAN:**
   - Убедитесь, что в `CMakeLists.txt` включён Address Sanitizer.
   - Сборка должна выполняться с флагом `-fsanitize=address`.

2. **Запуск программы:**
   - Запустите программу через CLion или терминал.

3. **Ожидаемый вывод от ASAN:**

```
Hello, World!
Goodbye!
=================================================================
==12345==ERROR: AddressSanitizer: double-free on address 0x602000000010 at pc 0x0000004006d9 bp 0x7ffeea3c6b80 sp 0x7ffeea3c6b78
    #0 0x4006d8 in String::~String() (./SanitizerExample+0x4006d8)
    #1 0x4007a5 in main (./SanitizerExample+0x4007a5)
    #2 0x7fff6c3c483f in start (libdyld.dylib+0x243f)

0x602000000010 is located 0 bytes inside of 14-byte region [0x602000000010,0x60200000001e)
freed by thread T0 here:
    #0 0x7fff8d55c5ef in free (libsystem_malloc.dylib+0x25ef)
    #1 0x4006c9 in String::~String() (./SanitizerExample+0x4006c9)
    #2 0x4007a5 in main (./SanitizerExample+0x4007a5)

previously allocated by thread T0 here:
    #0 0x7fff8d55c933 in malloc (libsystem_malloc.dylib+0x2933)
    #1 0x400688 in String::String(char const*) (./SanitizerExample+0x400688)
    #2 0x400755 in main (./SanitizerExample+0x400755)
```

### Интерпретация результатов

- **Double-free Error:** Санитайзер обнаружил, что память была освобождена дважды, что может привести к повреждению управляемых метаданных памяти и непредсказуемому поведению программы.
- **Стек вызовов:** Показывает, где именно в коде произошла ошибка, что значительно облегчает процесс отладки.

### Как исправить ошибки

1. **Избежать двойного удаления:**
   - После удаления указателя следует устанавливать его в `nullptr`:
     ```cpp
     delete s;
     s = nullptr;
     ```

2. **Использовать умные указатели:**
   - Применение умных указателей (`std::unique_ptr`, `std::shared_ptr`) может автоматизировать управление памятью и предотвратить подобные ошибки.

3. **Проверка перед удалением:**
   - Перед вызовом `delete` проверяйте, не равен ли указатель `nullptr`.

### Исправленный пример `main.cpp`

```cpp
#include <iostream>
#include <cstring>
#include <memory>

class String {

public:
    String(const char* str) {
        if (str) {
            size = std::strlen(str);
            data = new char[size + 1];
            std::strcpy(data, str);
        } else {
            size = 0;
            data = nullptr;
        }
    }

    ~String() {
        delete[] data;
    }

    void setString(const char* str) {
        if (data) {
            delete[] data;
        }
        size = std::strlen(str);
        data = new char[size + 1];
        std::strcpy(data, str);
    }

    void print() const {
        if (data) {
            std::cout << data << std::endl;
        }
    }

private:
    char* data;
    size_t size;
};

int main() {
    String* s = new String("Hello, World!");
    s->print();

    s->setString("Goodbye!");
    s->print();

    delete s;
    s = nullptr; // Устанавливаем указатель в nullptr после удаления

    // Дополнительная защита от двойного удаления
    if (s) {
        delete s;
    }

    return 0;
}
```

После внесения исправлений повторный запуск с Address Sanitizer не обнаружит ошибок двойного освобождения или утечек памяти.
