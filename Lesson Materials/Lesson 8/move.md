bruh

# Семантика перемещения в C++


Семантика перемещения была введена в C++11 для повышения эффективности работы с временными объектами и управления ресурсами. Она позволяет избежать излишнего копирования данных, что особенно важно для объектов, которые управляют большими объемами ресурсов, такими как память или дескрипторы.

## Копирование vs. Перемещение

### Пример с семантикой копирования

В традиционной семантике копирования (copy semantics) объект копируется путем создания его полного дубликата. Это подходит для простых типов, но может быть дорогим для объектов, которые содержат указатели на динамически выделенные ресурсы (например, `std::vector`, `std::string`).

Пример функции `swap` с копированием:

```cpp
template <typename T>
void swap(T& a, T& b) {
    T c = a; // Создание копии объекта a
    a = b;
    b = c;
}
```

В этом случае, все значения a копируются в c, и затем b копируется в a.

### Пример с семантикой перемещения

Перемещение позволяет "передать" внутренние ресурсы одного объекта другому. Вместо полного копирования, семантика перемещения захватывает ресурсы из временного объекта (по сути, передавая права на владение - подробно показывал на паре).

Пример функции `swap` с перемещением:

```cpp
#include <utility> // Для std::move

template <typename T>
void swap(T& a, T& b) {
    T c = std::move(a); // Перемещение ресурсов из a в c
    a = std::move(b);   // Перемещение ресурсов из b в a
    b = std::move(c);   // Перемещение ресурсов из c в b
}
```

Здесь `std::move` превращает объект в rvalue-ссылку, позволяя перемещающему конструктору (или оператору присваивания перемещением) захватить ресурсы из исходного объекта.

Перемещение полезно, например, при использовании контейнеров стандартной библиотеки, таких как `std::vector`. Когда элементы перемещаются, нет необходимости выделять и копировать массивы данных, увеличивая скорость выполнения и снижая использование памяти. Очевидно, это применимо и для ваших классов, типа того же стэка.


