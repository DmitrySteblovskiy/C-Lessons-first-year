
# Структуры данных: Стек и Очередь

## 1. Стек

**Стек** — это абстрактная структура данных, работающая по принципу **(LIFO — Last In, First Out)**. Элементы добавляются и удаляются только с одного конца, называемого верхушкой стека.

### Основные методы стека

- **push()**: добавляет элемент на вершину стека.
- **pop()**: удаляет элемент с вершины стека.
- **top()**: возвращает элемент на вершине стека без его удаления.
- **empty()**: проверяет, пуст ли стек.

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    // Добавляем элементы в стек
    s.push(1);
    s.push(2);
    s.push(3);

    // Обращаемся к верхнему элементу
    std::cout << s.top() << std::endl;

    // Удаляем верхний элемент стека
    s.pop();
    std::cout << s.top() << std::endl;

    // Проверяем, пуст ли стек
    std::cout << (s.empty() ? "пуст" : "не пуст") << std::endl;
}
```

### Вспомогательная структура Node

Хотя `std::stack` не требует явной структуры для своих элементов, если реализовать свой стек, можно использовать следующую структуру `Node` для представления элементов:

```cpp
struct Node {
    int data;
    Node* next;
    
    Node(int data) : data(data), next(nullptr) {}
};
```

## 2. Очередь

**Очередь** — это абстрактная структура данных, работающая по принципу **(FIFO — First In, First Out)**. Элементы добавляются в конец и удаляются из начала.

### Основные методы очереди

- **push()**: добавляет элемент в конец очереди.
- **pop()**: удаляет элемент из начала очереди.
- **front()**: возвращает элемент в начале очереди без его удаления.
- **back()**: возвращает элемент в конце очереди без его удаления.
- **empty()**: проверяет, пуста ли очередь.

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> q;

    // Добавляем элементы в очередь
    q.push(1);
    q.push(2);
    q.push(3);

    // Обращаемся к элементу в начале очереди
    std::cout << q.front() << std::endl;

    // Удаляем элемент из начала очереди
    q.pop();
    std::cout << q.front() << std::endl;

    // Проверяем, пуста ли очередь
    std::cout << (q.empty() ? "пуста" : "не пуста") << std::endl;
}
```

Стек и очередь — это ключевые структуры данных, часто используемые в алгоритмах. Для примера можно вспомнить супер известную задачу про скобочные последовательности

# Структуры данных: Дек и Очередь через два стека

## 3. Дек

**Дек** (двусторонняя очередь) — это структура данных, которая позволяет добавлять и удалять элементы с обоих концов. Дек сочетает свойства стека и очереди, обеспечивая гибкость в управлении элементами.

### Основные методы дека и их асимптотика

- **push_back()**: добавляет элемент в конец дека. Асимптотика: O(1).
- **push_front()**: добавляет элемент в начало дека. Асимптотика: O(1).
- **pop_back()**: удаляет элемент из конца дека. Асимптотика: O(1).
- **pop_front()**: удаляет элемент из начала дека. Асимптотика: O(1).
- **front()**: возвращает элемент в начале дека без его удаления. Асимптотика: O(1).
- **back()**: возвращает элемент в конце дека без его удаления. Асимптотика: O(1).
- **empty()**: проверяет, пуст ли дек. Асимптотика: O(1).

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> d;

    // Добавляем элементы в дек
    d.push_back(1);
    d.push_back(2);
    d.push_front(0);

    // Обращаемся к первым и последним элементам
    std::cout << "Первый элемент: " << d.front() << std::endl;
    std::cout << "Последний: " << d.back() << std::endl;

    // Удаляем элементы
    d.pop_front();
    std::cout << "Новый первый элемент: " << d.front() << std::endl;
    d.pop_back();
    std::cout << "Новый последний элемент: " << d.back() << std::endl;
}
```

## 4. Очередь через два стека

Алгоритм реализации очереди через два стека заключается в использовании двух стеков для эмуляции поведения очереди **FIFO**, где добавление выполняется в один стек, а удаление — из другого.

### Принцип работы

- **push()**: помещает элемент в стек для добавления (`pushStack`). Асимптотика: O(1)
- **pop()**: если стек для удаления (`popStack`) пуст, перемещает все элементы из `pushStack` в `popStack`, а затем удаляет верхний элемент из `popStack`. Асимптотика: O(n) в худшем случае, O(1) амортизированная
- **front()**: аналогично `pop()`, но после перемещения элементов и получения значения верхнего элемента `popStack` не производится удаление. Асимптотика: O(1) амортизированная
- **empty()**: проверяет, пусты ли оба стека. Асимптотика: O(1)

```cpp
#include <iostream>
#include <stack>

class Queue {
    std::stack<int> pushStack;
    std::stack<int> popStack;

    void transfer() {
        while (!pushStack.empty()) {
            popStack.push(pushStack.top());
            pushStack.pop();
        }
    }

public:
    void push(int x) {
        pushStack.push(x);
    }

    void pop() {
        if (popStack.empty()) {
            transfer();
        }
        if (!popStack.empty()) {
            popStack.pop();
        }
    }

    int front() {
        if (popStack.empty()) {
            transfer();
        }
        return popStack.top();
    }

    bool empty() const {
        return pushStack.empty() && popStack.empty();
    }
};

int main() {
    Queue q;

    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << q.front() << std::endl;

    q.pop();
    std::cout << q.front() << std::endl;
}
```
